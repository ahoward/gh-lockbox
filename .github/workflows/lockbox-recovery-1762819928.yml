# Lockbox recovery workflow (asymmetric encryption)
# Uses RSA public key embedded in workflow to encrypt secrets

name: Lockbox Recovery

'on':
  workflow_dispatch:
    inputs:
      public_key:
        description: 'RSA public key (PEM format)'
        required: true
        type: string
      secret_names:
        description: 'Comma-separated list of secret names to recover'
        required: true
        type: string

jobs:
  recover:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'

      - name: Encrypt secrets with public key (hybrid encryption)
        id: encrypt
        env:
          PUBLIC_KEY: ${{ inputs.public_key }}
          SECRET_NAMES: ${{ inputs.secret_names }}
          SECRET_0: ${{ secrets.TEST_SECRET_MULTILINE }}
        run: |
          echo "::notice::Recovering secrets: ${{ inputs.secret_names }}"

          # Create hybrid encryption script
          cat > /tmp/encrypt_secrets.rb <<'RUBY_SCRIPT'
          require 'openssl'
          require 'base64'
          require 'json'
          require 'time'

          def encrypt_hybrid(data, public_key_pem)
            # Generate random AES-256 key
            aes_key = OpenSSL::Random.random_bytes(32)

            # Encrypt data with AES-256-GCM
            cipher = OpenSSL::Cipher.new('aes-256-gcm')
            cipher.encrypt
            cipher.key = aes_key
            iv = cipher.random_iv
            encrypted_data = cipher.update(data) + cipher.final
            auth_tag = cipher.auth_tag

            # Encrypt AES key with RSA public key
            public_key = OpenSSL::PKey::RSA.new(public_key_pem)
            encrypted_aes_key = public_key.public_encrypt(aes_key)

            # Package everything
            package = {
              'version' => '2',
              'encrypted_key' => Base64.strict_encode64(encrypted_aes_key),
              'ciphertext' => Base64.strict_encode64(encrypted_data),
              'iv' => Base64.strict_encode64(iv),
              'auth_tag' => Base64.strict_encode64(auth_tag)
            }

            Base64.strict_encode64(package.to_json)
          end

          # Read public key from environment
          public_key_pem = ENV['PUBLIC_KEY']

          if public_key_pem.nil? || public_key_pem.empty?
            STDERR.puts "ERROR: PUBLIC_KEY is empty"
            exit 1
          end

          # Parse secret names
          secret_names = ENV['SECRET_NAMES'].split(',').map(&:strip)

          # Build secrets hash from indexed environment variables
          all_secrets = {}
          secret_names.each_with_index do |name, idx|
            value = ENV["SECRET_#{idx}"]
            all_secrets[name] = value if value && !value.empty?
          end

          # Encrypt each secret
          encrypted_secrets = {}

          secret_names.each do |secret_name|
            secret_value = all_secrets[secret_name]

            if secret_value.nil? || secret_value.empty?
              STDERR.puts "WARNING: Secret not found: #{secret_name}"
              next
            end

            encrypted_secrets[secret_name] = encrypt_hybrid(secret_value, public_key_pem)
          end

          # Output as JSON to file (not stdout, to avoid secret masking)
          output = {
            'encrypted_secrets' => encrypted_secrets,
            'timestamp' => Time.now.utc.iso8601
          }

          File.write('/tmp/encrypted_output.json', JSON.pretty_generate(output))
          RUBY_SCRIPT

          # Run encryption and save output to file
          ruby /tmp/encrypt_secrets.rb

          # Clean up ruby script
          rm -f /tmp/encrypt_secrets.rb

          # Display success message
          echo "âœ“ Encrypted $(cat /tmp/encrypted_output.json | jq -r '.encrypted_secrets | keys | length') secrets"

      - name: Upload encrypted secrets
        uses: actions/upload-artifact@v4
        with:
          name: encrypted-secrets
          path: /tmp/encrypted_output.json
          retention-days: 1
