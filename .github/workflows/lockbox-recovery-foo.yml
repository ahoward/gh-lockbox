# This is a template file that will be customized per secret
# Placeholders: FOO, FOO

name: Lockbox Recovery - FOO

'on':
  workflow_dispatch:
    inputs:
      gist_id:
        description: 'Recovery gist ID'
        required: true
        type: string

jobs:
  recover:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'

      - name: Fetch and decrypt recovery key from gist
        id: find_key
        env:
          GIST_ID: ${{ inputs.gist_id }}
          SECRET_NAME: FOO
          REPO: ${{ github.repository }}
        run: |
          echo "::notice::Fetching recovery gist: ${GIST_ID}"

          # Fetch public gist (no auth needed)
          gist_json=$(curl -sf "https://api.github.com/gists/${GIST_ID}")

          if [ -z "$gist_json" ]; then
            echo "::error::Failed to fetch recovery gist"
            exit 1
          fi

          # Extract encrypted content from the gist
          encrypted_content=$(echo "$gist_json" | jq -r '.files | to_entries | first | .value.content')

          if [ -z "$encrypted_content" ]; then
            echo "::error::Failed to extract gist content"
            exit 1
          fi

          # Decrypt gist content using secret_name + repo as key
          cat > /tmp/decrypt_gist.rb <<'RUBY_DECRYPT'
          require 'openssl'
          require 'base64'
          require 'json'
          require 'digest'

          def derive_key(pass)
            Digest::SHA256.digest(pass)
          end

          def decrypt(encrypted_blob, pass)
            key = derive_key(pass)
            package = JSON.parse(Base64.strict_decode64(encrypted_blob))

            cipher = OpenSSL::Cipher.new('aes-256-gcm')
            cipher.decrypt
            cipher.key = key
            cipher.iv = Base64.strict_decode64(package['iv'])
            cipher.auth_tag = Base64.strict_decode64(package['auth_tag'])

            decrypted = cipher.update(Base64.strict_decode64(package['ciphertext'])) + cipher.final
            decrypted
          end

          encrypted = ENV['ENCRYPTED_CONTENT']
          encryption_key = "#{ENV['SECRET_NAME']}:#{ENV['REPO']}"

          decrypted_json = decrypt(encrypted, encryption_key)
          gist_data = JSON.parse(decrypted_json)

          puts gist_data['key']
          RUBY_DECRYPT

          TEMP_KEY=$(ENCRYPTED_CONTENT="$encrypted_content" ruby /tmp/decrypt_gist.rb)
          rm -f /tmp/decrypt_gist.rb

          if [ -z "$TEMP_KEY" ]; then
            echo "::error::Failed to decrypt temp key from gist"
            exit 1
          fi

          # Export temp key for next step (masked from logs)
          echo "::add-mask::$TEMP_KEY"
          echo "temp_key=$TEMP_KEY" >> $GITHUB_OUTPUT

      - name: Encrypt secret with temp recovery key
        id: encrypt
        env:
          SECRET_VALUE: ${{ secrets.FOO }}
          TEMP_KEY: ${{ steps.find_key.outputs.temp_key }}
        run: |
          echo "::notice::Recovering secret: FOO"

          if [ -z "$SECRET_VALUE" ]; then
            echo "::error::Secret value not found: FOO"
            exit 1
          fi

          if [ -z "$TEMP_KEY" ]; then
            echo "::error::Temp key not found"
            exit 1
          fi

          # Create a temporary Ruby script to encrypt the secret
          cat > /tmp/encrypt.rb <<'RUBY_SCRIPT'
          require 'openssl'
          require 'base64'
          require 'json'
          require 'digest'
          require 'time'

          def derive_key(temp_key)
            # Use SHA-256 to hash the UUID into a 32-byte key
            # SHA-256 always produces exactly 32 bytes (256 bits)
            Digest::SHA256.digest(temp_key)
          end

          def encrypt(data, temp_key)
            cipher = OpenSSL::Cipher.new('aes-256-gcm')
            cipher.encrypt

            key = derive_key(temp_key)
            cipher.key = key
            iv = cipher.random_iv
            encrypted = cipher.update(data) + cipher.final
            auth_tag = cipher.auth_tag

            package = {
              'version' => '1',
              'ciphertext' => Base64.strict_encode64(encrypted),
              'iv' => Base64.strict_encode64(iv),
              'auth_tag' => Base64.strict_encode64(auth_tag)
            }

            Base64.strict_encode64(package.to_json)
          end

          # Read from environment
          secret_value = ENV['SECRET_VALUE']
          temp_key = ENV['TEMP_KEY']

          if secret_value.nil? || secret_value.empty?
            puts "ERROR: SECRET_VALUE is empty"
            exit 1
          end

          if temp_key.nil? || temp_key.empty?
            puts "ERROR: TEMP_KEY is empty"
            exit 1
          end

          # Encrypt the secret with the temp key
          encrypted = encrypt(secret_value, temp_key)

          # Output as JSON for reliable parsing
          output = {
            'encrypted_blob' => encrypted,
            'timestamp' => Time.now.utc.iso8601
          }

          puts JSON.pretty_generate(output)
          RUBY_SCRIPT

          # Run the encryption script and capture output
          encrypted_json=$(ruby /tmp/encrypt.rb)

          # Clean up
          rm -f /tmp/encrypt.rb

          # Extract encrypted blob from JSON and set as step output
          encrypted_blob=$(echo "$encrypted_json" | jq -r '.encrypted_blob')
          echo "encrypted_blob=$encrypted_blob" >> $GITHUB_OUTPUT

          # Also output the full JSON for debugging
          echo "$encrypted_json"
